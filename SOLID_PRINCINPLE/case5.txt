Background: An online store needs a backend to handle order placement, track payment, and manage shipment information. Each order involves checking inventory, processing payments, and updating shipment status. The system should also notify customers of order status changes and generate invoices for each order. 

Question: What are the classes you might need in this software solution?



type ItemType={
    id: string,
    name: string,
    price: number,
    quantity: number
}

type OrderType ={
    id: string,
    itemId: number,
    numberOfItem: number,
   
    status: string,
    paymentid?:string,
}



interface IPayment{
    pay()
    refund()
}

interface INotification{
    send()
}


class Payment implements IPayment{
    private price;
    constructor(price){
        this.price = price;
    }
    pay(){
      
        return true;
    }

    refund(){
        return true;
    }

}



class PaymentProcessor{
  payment: IPayment;

    constructor(payment){
        this.payment = payment;
    }
    processPayment(): string{
       
        return  this.payment.pay();
    }

    processRrefund(paymentid){
        
        return this.payment.refund(paymentid);
    }
}


class Notification implements INotification{
    message: string;
    setMessage(message){
        this.message = message;
    }

    send(){
        return true;
    }
}

class NotificationProcessor{

    notification: INotification;

    constructor(notification){
        this.notification = notification
    }
    sendMessage(message){
        return this.notification.send(message)
    }
}
 

// it's just a sample
 new Worker("notificationQueue", async (job) => {
  const { order, message } = job.data;
  const processor = new NotificationProcessor();
  await processor.processNotification(order, message);
});




class Order {
    private order:OrderType;
    private notificationQueue;

    constructor(order:OrderType){
        this.order = order;
    }

    setStatus(status, message){
        this.order.status = status;
        this.notificationQueue.add("status",  this.order, message);
    }

    setPayment(paymentid){
        this.order.paymentid = paymentid;
    }

}



class Store{
    private inventories:ItemType[] = [];
    private orderIds:string[] = [];

    addItems (itemId, numberOfItem, name, price){

        if(this.inventories.find(item => item.id === itemId)){
                item.quantity+=numberOfItem;
                item.name= name;
                item.price = price;
                
        }
        else{
        const inventory = {
                id: generateUid(),
                name: name,
                price : price,
                quantity : numberOfItem
                  }
            this.inventories.push(inventory);
        }
       
    }

    decreaseItems(itemId, numberOfItem){
            item = this.inventories.find(item => item.id === itemId);
            if(item){
                item.quantity-=numberOfItem;
            }
                
     
    }

    hasItem(itemId){
        return this.inventories.find(item => item.id === itemId);
    }

    buyItems(itemId, numberOfItem, orderId, paymentid){
        this.decreaseItems(itemId, numberOfItem);
        this.orderIds.push(orderId);
    }

   

}



main(){

        const ItemTobeOrdered = "a6df";
        const numberOfItem = 4;
        const store = new Store();
        const item = store.hasItem(ItemTobeOrdered);
        if(item){
            
            const orderId = generateUid();
            
            const order = new Order(orderId, ItemTobeOrdered, numberOfItem);
             order.setStatus("orderPlaced", "Successfully orderPlaced");
            if(order){
                payment1 = new Payment(item.price);

                paymentProcessor = new PaymentProcessor(payment1);
                const paymentid =   paymentProcessor.processPayment();

                if(paymentid){
                    try{
                        order.setStatus("Paid", "Successfully Purchased");
                        store.buyItems(item.id, numberOfItem, order.id, paymentid);
                
                        order.setStatus("Purchased", "Successfully Purchased");
                        order.setPayment(paymentid)
                    }
                    catch(error){
                        paymentProcessor.processRrefund(paymentid);
                    }        

                } 

            }
            

                                                 
        }
        

}


